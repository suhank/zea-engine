<!doctype html>
<html class="docs-version-current" lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.6">
<title data-react-helmet="true">Architecture | Zea Engine Docs</title><meta data-react-helmet="true" name="twitter:card" content="summary_large_image"><meta data-react-helmet="true" property="og:url" content="https://www.zea.live//zea-engine/Manual/Concepts/arch-overview"><meta data-react-helmet="true" name="docusaurus_locale" content="en"><meta data-react-helmet="true" name="docusaurus_version" content="current"><meta data-react-helmet="true" name="docusaurus_tag" content="docs-default-current"><meta data-react-helmet="true" property="og:title" content="Architecture | Zea Engine Docs"><meta data-react-helmet="true" name="description" content="Zea Engine is a web based visualization SDK for professional graphics applications. It was designed around 3 key motivations."><meta data-react-helmet="true" property="og:description" content="Zea Engine is a web based visualization SDK for professional graphics applications. It was designed around 3 key motivations."><link data-react-helmet="true" rel="shortcut icon" href="/zea-engine/img/favicon.ico"><link data-react-helmet="true" rel="canonical" href="https://www.zea.live//zea-engine/Manual/Concepts/arch-overview"><link data-react-helmet="true" rel="alternate" href="https://www.zea.live//zea-engine/Manual/Concepts/arch-overview" hreflang="en"><link data-react-helmet="true" rel="alternate" href="https://www.zea.live//zea-engine/Manual/Concepts/arch-overview" hreflang="x-default"><link rel="stylesheet" href="/zea-engine/assets/css/styles.90bf0d28.css">
<link rel="preload" href="/zea-engine/assets/js/runtime~main.14def733.js" as="script">
<link rel="preload" href="/zea-engine/assets/js/main.83d89e4b.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div><a href="#" class="skipToContent_1oUP">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/zea-engine/"><img src="/zea-engine/img/logo-zea.svg" alt="Zea logo" class="themedImage_1VuW themedImage--light_3UqQ navbar__logo"><img src="/zea-engine/img/logo-zea.svg" alt="Zea logo" class="themedImage_1VuW themedImage--dark_hz6m navbar__logo"><b class="navbar__title"></b></a><a class="navbar__item navbar__link navbar__link--active" href="/zea-engine/">Manual</a><a class="navbar__item navbar__link" href="/zea-engine/API/index">API</a><a class="navbar__item navbar__link" href="/zea-engine/Tutorials/tutorials">Tutorials</a><a class="navbar__item navbar__link" href="/zea-engine/Plugins/plugins-templates-overview">Plugins</a><a class="navbar__item navbar__link" href="/zea-engine/Community/c1">Community</a></div><div class="navbar__items navbar__items--right"><a href="https://zea.live" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link"><span>zea.live<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div class="main-wrapper docs-wrapper docs-doc-page"><div class="docPage_31aa"><button class="clean-btn backToTopButton_35hR" type="button"><svg viewBox="0 0 24 24" width="28"><path d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z" fill="currentColor"></path></svg></button><aside class="docSidebarContainer_3Kbt"><div class="sidebar_15mo"><nav class="menu thin-scrollbar menu_Bmed menuWithAnnouncementBar_2WvA"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" href="/zea-engine/">Overview</a></li><li class="theme-doc-sidebar-item-category menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">Getting Started</a></li><li class="theme-doc-sidebar-item-category menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#">Concepts</a><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/zea-engine/Manual/Concepts/zea-engine-architecture">Concepts Overview</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/zea-engine/Manual/Concepts/arch-overview">Architecture</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/zea-engine/Manual/Concepts/transformations">Transformations</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/zea-engine/Manual/Concepts/events">Events and Listeners</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/zea-engine/Manual/Concepts/geometry-rendering">Geometry and Rendering</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/zea-engine/Manual/Concepts/pbr-rendering">PBR (Physically Based Rendering)</a></li></ul></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" href="/zea-engine/Manual/resources">Resources</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" href="/zea-engine/Manual/CHANGELOG">Changelog</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" href="/zea-engine/Manual/acknowledgements">Acknowledgements</a></li></ul></nav></div></aside><main class="docMainContainer_3ufF"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_3FnS"><div class="docItemContainer_33ec"><article><div class="tocCollapsible_1PrD theme-doc-toc-mobile tocMobile_3Hoh"><button type="button" class="clean-btn tocCollapsibleButton_2O1e">On this page</button></div><div class="theme-doc-markdown markdown"><header><h1>Architecture</h1></header><p>Zea Engine is a web based visualization SDK for professional graphics applications. It was designed around 3 key motivations.</p><ul><li>Performance</li><li>Versatility</li><li>Extensibility</li></ul><p>In this article we explore the high level architecture of the engine and how the main parts relate to each other.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="performance"></a>Performance<a class="hash-link" href="#performance" title="Direct link to heading">#</a></h3><p>The architecture of Zea Engine enables high performance visualization by providing a highly optimized code path for WebGL based rendering. The Renderer / Scene Tree abstraction enables the renderer to build a rendering path optimized for efficient GPU utilization, while the scene tree provides a representation useful in the construction of large complex 3d scenes.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="versatility"></a>Versatility<a class="hash-link" href="#versatility" title="Direct link to heading">#</a></h3><p>Zea Engine was designed to follow the highly versatile and powerful scene representations found in high end Visual Effects packages like Autodesk Maya™ and Autodesk Softimage™. These tools were designed to support a wide range of requirements, and domains from Film VFX Production through to Design Visualization. A key goal of Zea Engine is to support a wide range of rendering requirements, complex motion driven by either predefined animation sequences, or procedural algorithms, and user interaction models. Being in the web space, Zea Leverages the simple yet powerful event model found in the browser, while adding a layer of tools for building 3d user interface widgets and interaction models.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="extensibility"></a>Extensibility<a class="hash-link" href="#extensibility" title="Direct link to heading">#</a></h3><p>To allow an infinite number of use cases for Zea Engine, all aspects of the toolkit from the scene tree, interaction system and also the renderer support extension through plugins that can implement custom behaviors and features. The Scene Tree is a pluggable system that supports custom tree nodes to be added which can contain any type of data, expose custom functions, and provide interaction tools. These custom tree nodes can be persisted and restored like the builtin nodes and enable the scene tree to be extended to handle any data representation required. The Operator system that computes changes in the Scene Tree data is pluggable so custom procedural motion or effects can be implemented. The Renderer supports plugins that can take responsibility for displaying custom nodes in the tree, making it possible to integrate any custom rendering effects, while integrating with existing rendering solutions, and supporting features such as VR or AR.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_31ik" id="dom-analogy"></a>DOM Analogy<a class="hash-link" href="#dom-analogy" title="Direct link to heading">#</a></h2><p>The architecture of the Engine is analogous to the architecture of the DOM and the browser. The DOM provides a flexible and powerful model for building web applications, and so the Engine was designed around similar principals.</p><p>Within the browser, we have a DOM, which is a tree structure of elements that define various aspects of the rendered page.</p><p><strong>Document &gt; Scene</strong></p><p>The Document object in the browser is analogous to the Scene object in the Engine.</p><p><strong>Div &gt; TreeItem</strong></p><p>Within the DOM, there are HTML elements that are used purely for layout. The \&lt;div&gt; is an element within the tree that is often used for layout, to provide position for child items.
Within the engine, the TreeItem provides a similar purpose. The TreeItem is not rendered in any way, but can be used to position child elements relative to itself. The Tree item defines the structure of the tree.</p><p><strong>Image / Text &gt; GeomItem</strong></p><p>The rendered items of the DOM tree such as text or image nodes are analogous to the GeomItem, and other nodes that are rendered to screen by the renderer.</p><p><strong>HTML -&gt; JSON / Asset files</strong></p><p>The Browser loads an HTML file , parses the XML and uses this data to build the DOM tree. Similarly, the engine can load various file formats that are parsed and used to build the scene tree.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="events"></a>Events<a class="hash-link" href="#events" title="Direct link to heading">#</a></h3><p>Another important way that the engine was modeled on the browser is the way events are captured, bubbled, and handled. The engine emulates the way the browser implements these important stages and provides a similar interface to interacting with 3d geometry as the DOM does for 2d elements in the page.</p><blockquote><p>The techniques used to make objects draggable in the DOM can be applied to making geometry draggable in a 3d scene. Of course, the math is in 3d, instead of 2d which can be a lot more complex.</p></blockquote><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="web-components"></a>Web Components<a class="hash-link" href="#web-components" title="Direct link to heading">#</a></h3><p>An important new feature in modern browsers is web components. This feature makes it possible for developers to implement new custom DOM elements. Custom web components make the DOM tree &#x27;pluggable&#x27;, and enables a developer to extend the definition of the DOM.</p><blockquote><p>For an introduction to Web Components, read the following: <a href="https://developer.mozilla.org/en-US/docs/Web/Web_Components" target="_blank" rel="noopener noreferrer">https://developer.mozilla.org/en-US/docs/Web/Web_Components</a></p></blockquote><p>In the same way, plugin developers working with the engine and define custom tree nodes, rendering plugins and math types that integrate with the builtin classes.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor anchor__h4 anchorWithStickyNavbar_31ik" id="registry"></a>Registry<a class="hash-link" href="#registry" title="Direct link to heading">#</a></h4><p>These custom DOM elements can be specified in the HTML code and as the browser is parsing the XML, it checks in the CustomElementRegistry for these custom nodes.
<a href="https://developer.mozilla.org/en-US/docs/Web/API/CustomElementRegistry" target="_blank" rel="noopener noreferrer">https://developer.mozilla.org/en-US/docs/Web/API/CustomElementRegistry</a></p><p>The Engine provides a similar registry that plugin developers can register custom tree items with. These custom tree items can then be saved and loaded along with all of the builtin tree items that are provided by the engine.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_31ik" id="scene-tree"></a>Scene Tree<a class="hash-link" href="#scene-tree" title="Direct link to heading">#</a></h2><p><img alt="scene-tree" src="/zea-engine/assets/images/scene-tree-c714b80c11ecc88a57a290a2250fbc85.svg">
<em>A simple scene tree containing a tree item, one geom Item, and an Asset containing a couple of Geom Items.</em></p><p>The Scene tree structures the data that is rendered by the renderer. The Scene tree provides a hierarchy of nodes, each containing data in the form of Parameters, and potentially custom JavaScript objects.</p><blockquote><p>For more information on the main building block of the tree, please refer to the <a href="/zea-engine/API/SceneTree/SceneTree_TreeItem.TreeItem">TreeItem</a> documentation.</p></blockquote><p><strong>Why a Tree and not a Graph</strong></p><p><img alt="tree-vs-dag" src="/zea-engine/assets/images/tree-vs-dag-1bb5cf7ae2c58c0327b245555171e690.svg"></p><p>Many scene descriptions and described as a Scene Graph, or even a Direct Acyclic Graph(DAG). A Graph is more flexible in that any item can have 1 or more parents. A Graph provides an elegant definition of instancing because it implies that any item in the Graph can have 1 or more transformations in the 3d scene. A scene tree, in contrast, implies that any tree item can have one and only one transformation in the 3d scene. While this constraint creates some limitations on how data can be organized, it simplifies many aspects of how a developer interacts with and understands the scene they are building.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="parameters"></a>Parameters<a class="hash-link" href="#parameters" title="Direct link to heading">#</a></h3><p><img alt="parameter-owner-params" src="/zea-engine/assets/images/parameter-owner-params-9b070ec1b5966082ef5e63ed3437f98d.svg"></p><p>Within the Scene Tree, each item in the tree contains a collection of parameters. Each parameter has a name and a value. Parameters can be added and removed from Tree items and provide a standard interface to access data stored within the tree.</p><p>Parameters provide a composition model for defining data storage in the scene.</p><p>Parameters provide a standard interface to data stored in the scene tree. Parameters emit events when their values are changed, which allows user interfaces and other tools to observe the Parameters and respond to changes.</p><p>Parameters can also be displayed using ParameterWidgets, which are user interface components found in the zea-web-components library.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="paths"></a>Paths<a class="hash-link" href="#paths" title="Direct link to heading">#</a></h3><p>Any item in the tree, or parameter can be reached by traversing the tree and accessing parameters. Each Tree item and Parameter can also return its path within the tree.</p><p><img alt="scene-tree-paths" src="/zea-engine/assets/images/scene-tree-paths-0d759262bcede1f2c9c5a531cef788d1.svg"></p><p>In the following scene, a cylinder geometry is attached to a GeomItem which is nested under TreeItem1. The path for the Radius parameter is the following:</p><p><strong>[“Root”, “TreeItem1”, “GeomItem”, “Geometry”, “Radius”]</strong></p><blockquote><p>Note: The names of parameters must not conflict with names of child tree items. So a child item could not have the name “GlobalXfo” because that would conflict with the parameter that exists no each Tree item.</p></blockquote><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="operators"></a>Operators<a class="hash-link" href="#operators" title="Direct link to heading">#</a></h3><p>Operators are used to compute new values for Parameters within the scene tree. Operators make the scene tree dynamic and able to maintain relationships between parameters, update based on changes, and drive animation.</p><p><img alt="operators-ABC" src="/zea-engine/assets/images/operators-ABC-25ae9a2093a7fd4ccda5554f78532764.svg">
<em>In this diagram above, the value of Parameter C is calculated by Operator A using the values of Parameter A and Parameter B as inputs.</em></p><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="lazy-evaluation"></a>Lazy Evaluation<a class="hash-link" href="#lazy-evaluation" title="Direct link to heading">#</a></h3><p>When a parameter is modified, by a user action or other mechanism such as a timer, the parameter emits a message to inform any connected operators that its value is now different, and the operators will need to calculate new values for the parameters connected to its outputs.</p><p>However, the operator does not immediately start this calculation. Instead it waits to see if anything in the system requires this new value of its outputs to be calculated. It does this by emitting a message to its outputs to tell them that their values have also changed. The parameters that receive this message simply set themselves as ‘dirty’ and emit their own message further into the scene tree.
These messages propagate throughout the tree until they reach an observer that is connected to a parameter and requests its updated value.
On request, the operator requests the operators to finally calculate the updated value. Each operator asks it inputs for their values, which causes them to ask any input parameters for their values. This propagates back up the scene tree until it reaches the original operator whose value was modified.</p><p><img alt="operators-lazy-evaluation" src="/zea-engine/assets/images/operators-lazy-evaluation-8060d2994adfb7b76d77162c39da3cee.svg"></p><blockquote><p>Parameter 1 is changed by some mechanism. Maybe a timer changes its value periodically or a user edits it using a user interface component.If Parameter 1 is changed, then Parameters 2 and 3 become ‘dirty’ and this propagates to 4, 5 &amp; 6. An Observer, potentially the renderer, or another user interface component, is watching Parameters 4 &amp; 5. It receives an event indicating that they have become dirty, so it retrieves their values. This causes Op 1 and then Op 2 to evaluate producing the new updated values for Parameters 4 &amp; 5. No Observer is watching Param 6, so Op 3 is not evaluated and so Param 6 value is never calculated. Param 6 remains dirty until its value is needed.</p></blockquote><h4><a aria-hidden="true" tabindex="-1" class="anchor anchor__h4 anchorWithStickyNavbar_31ik" id="benefits-of-lazy-evaluation"></a>Benefits of Lazy Evaluation<a class="hash-link" href="#benefits-of-lazy-evaluation" title="Direct link to heading">#</a></h4><p>Lazy evaluation enables connected observers like the Renderer, to batch evaluations of the scene tree at the frequency of rendering. This can lead to efficiencies as the scene does not get evaluated in between rendered frames.
It can also be helpful if items are hidden from view, at which point, the renderer no longer requests their values. The value of hidden objects are not updated, unless something requests their value like a connected user interface.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor anchor__h4 anchorWithStickyNavbar_31ik" id="scene-tree-class-hierarchy"></a>Scene Tree Class Hierarchy<a class="hash-link" href="#scene-tree-class-hierarchy" title="Direct link to heading">#</a></h4><p><img alt="scene-class-hierarchy" src="/zea-engine/assets/images/scene-class-hierarchy-29e016c4e5f21a87a325504864399522.svg"></p><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="renderer"></a>Renderer<a class="hash-link" href="#renderer" title="Direct link to heading">#</a></h3><p>While the Scene tree provides a structure useful in organizing according to hierarchies useful for our understanding of the environment being displayed, the Renderer, through the system of passes, enables the organization of data around the requirements of efficient rendering on the GPU. Each Pass in the Renderer takes responsibility for rendering parts of the scene tree. The builtin passes generally handle the standard geometries that are provided in the scene tree, and custom passes can be registered to handle custom geometries that could be added to the scene tree.</p><p><img alt="scene-tree-renderer" src="/zea-engine/assets/images/scene-tree-renderer-4de0a7641954a3122ba630b090009b85.svg">
<em>A simple scene tree containing a tree item, one geom Item, and an Asset containing a couple of Geom Items. The Renderer contains a collection of passes that are observing the various parts of the scene tree.</em></p><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="renderer-as-an-observer-of-the-scene-tree"></a>Renderer as an observer of the Scene Tree<a class="hash-link" href="#renderer-as-an-observer-of-the-scene-tree" title="Direct link to heading">#</a></h3><p>The Renderer is implemented as an observer of the scene tree. The Scene Tree has no knowledge of the renderer and does not have access to rendering functionality. All rendering functionality is maintained in the Renderer, including the canvas element, the rendering context, all rendering specific data and shaders.</p><p>Whenever the scene tree changes in any way, the renderer receives events which allow it to respond to the changes, update rendering state and trigger redrawing to the canvas bound to the renderer.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="passes"></a>Passes<a class="hash-link" href="#passes" title="Direct link to heading">#</a></h3><p>The renderer maintains a stack of passes that are each responsible for rendering different types of data found in the scene tree. When the Renderer binds to the scene tree, it traverses the tree and for each TreeItem, checks to see if any of its Passes would take responsibility for rendering that item.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor anchor__h4 anchorWithStickyNavbar_31ik" id="pass-types"></a>Pass Types<a class="hash-link" href="#pass-types" title="Direct link to heading">#</a></h4><p>As passes are registered with the renderer, they are grouped according to 3 types.</p><ul><li>Opaque</li><li>Transparent</li><li>Overlay</li></ul><p><strong>Opaque</strong>
Opaque passes are always invoked first, and should render geometries that are not transparent in any way. Opaque passes have more flexibility in how they manage rendering, because blending is not applied. The GLOpaqueGeoms pass manages rendering standard Points, Lines and Mesh geometries and is the first pass to be invoked. It performs a rendering process that automatically draws instanced geometries, and is optimized to minimize Geometry, Material and Shader switches.</p><p><strong>Transparent</strong>
Transparent passes are invoked after the Opaque passes have completed, and typically involve rendering geometries blended over the top of existing geometries.</p><p>Transparent geometries typically need to be rendered from back to front to achieve correct blending results.</p><blockquote><p>Note: Each transparent pass should configure the GL blend modes before rendering.</p></blockquote><p>The main pass for rendering transparent geometries is ‘GLTransparentGeomsPass’, which renders standard Points, Lines and Mesh geometries. It handles sorting the geoms according to their distance to the camera and switching materials and shaders if needed during the rendering process.</p><blockquote><p>Note: Each Transparent pass is rendered in sequence, so it is not possible to have transparent geometry from one pass depth sorted with geometries from another pass. This means, for example, that a label behind a glass window would appear over the top of the glass window, because the GLBillboards pass is invoked after the GLTransparentGeomsPass.</p></blockquote><p><strong>Overlay</strong>
Overlay passes are rendered after all Opaque and Transparent passes, and are used to render geometries that are considered ‘overlaid’ on the scene, and not occluded by scene geometry. This can include user interface geometry that should never be always visible regardless of its position in the 3d scene.</p><blockquote><p>Note: Geometry can be rendered using shaders that position geometry in the 2d coordinates of the viewport, and not 3d geometry projected onto the 2d surface using the camera&#x27;s projection matrix.</p></blockquote><blockquote><p>Note: The depth buffer is cleared before invoking the overlay passes. This prevents scene geometry from obscuring overlay geoms. However, Overlay geoms can obscure each other as the depth buffer is re-written.</p></blockquote><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="adaptors"></a>Adaptors<a class="hash-link" href="#adaptors" title="Direct link to heading">#</a></h3><p>The Renderer uses a system of adapters to manage the relationship between the Objects and data stored in the Scene Tree and the memory on the GPU. For each type of Scene Tree item that is used in rendering, there is an adapter provided that manages the GPU resources for that object.</p><p><img alt="renderer-adaptors" src="/zea-engine/assets/images/renderer-adaptors-39d062d5b1aaa8efaddbbe0387b6d6e0.svg"></p><blockquote><p>The role of the adaptor is to observe the data object, listen to changes, and update the GPU memory whenever necessary as the scene changes. If the data object is removed from the scene tree, the adaptor should clean up any GPU resources allocated for that object.</p></blockquote><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="evented-rendering"></a>Evented Rendering<a class="hash-link" href="#evented-rendering" title="Direct link to heading">#</a></h3><p>Rendering only occurs when some part of the rendering system detects a change in the scene tree it is observing. Upon detection of a change, the renderer updates any rendering specific data and then redraws. When the Renderer is initially constructed, it requests the first frame to be rendered, after which evented rendering starts.</p><blockquote><p>“In a static scene, If no user interaction occurs, then no rendering occurs.”</p></blockquote><p>By only rendering in response to changes in the scene tree, the renderer strikes a balance between responsiveness and efficiency. This architecture means that rendering is not continuously occurring while the scene is static. In a static scene, meaning no animation or changes are being caused by external event systems like timers, then the renderer rests dormant waiting for a change until it receives its next change notification.</p><p><em>Example: In a static scene, a user is viewing some large model and discussing with colleagues on a lightweight mobile device. The conversation might last 30 minutes. During the conversation, at different times, the user interacts with the scene a few times to change the position and orientation of the camera to focus on parts of the model. Rendering of the model only occurs during those interactions. The rest of the time the renderer is dormant consuming no resources, leading to longer battery life.
</em></p><blockquote><p>“In a dynamic scene, rendering updates are triggered whenever the dynamic scene changes, or if the user interacts in some way”</p></blockquote><p><strong>Example: In a heavy scene on a lightweight device, an animation is playing at a frequency of 20ms, or 50fps. The renderer can only render at a maximum of 40fps. During rendering of each frame, the scene can be considered ‘clean’, because the renderer has pulled all the relevant data and all operators are up to date. The scene then updates again before the rendering completes, and the renderer queues up another frame. A second time the scene may update, but the renderer has not yet cleaned the scene, so nothing changes. As soon as possible, the renderer starts rendering the subsequent frame, and will clean the scene.</strong></p><p>In this way, the renderer and scene can update at independent frequencies.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="continuous-rendering"></a>Continuous Rendering<a class="hash-link" href="#continuous-rendering" title="Direct link to heading">#</a></h3><p>By comparison, maybe renderers, especially simple ones like Tree JS, or engines designed around the requirements of games, tend to render as fast as possible at all times. In Games, this is typically desired. The renderer in a game runs at a fixed 60fps at all times and usually the scenes are continuously changing and require re-rendering. The renderer frequency is not tied to user interactions, and instead on a simple timer and update loop.</p><p>When utilizing the WebXR api in Zea Engine, during a VR/AR session, the renderer switches to continuous rendering instead of evented rendering to ensure the smoothest experience.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="arvr"></a>AR/VR<a class="hash-link" href="#arvr" title="Direct link to heading">#</a></h3><p>Zea Engine supports a wide range of AR and VR devices through the WebXR api available in most browsers today. Through WebXR, web based apps built using Zea Engine can leverage a very wide range of hardware.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor anchor__h4 anchorWithStickyNavbar_31ik" id="mobilecardboard-vr"></a>Mobile/Cardboard VR<a class="hash-link" href="#mobilecardboard-vr" title="Direct link to heading">#</a></h4><p>While the GPU on mobile devices are getting more powerful every year, they are still orders of magnitude slower than their desktop counterparts. However, for small simple scenes containing only a few thousand triangles, they are fast enough to deliver impressive virtual reality experiences.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor anchor__h4 anchorWithStickyNavbar_31ik" id="desktop-vr"></a>Desktop VR<a class="hash-link" href="#desktop-vr" title="Direct link to heading">#</a></h4><p>For a high end VR experience, there are a range of options such as the HTC Vive or Oculus Rift that work very well within the browser with Zea Engine. Full head and controller tracking is provided and the performance of Zea Engine enables quite amazing experiences to be built.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor anchor__h4 anchorWithStickyNavbar_31ik" id="untethered-ar"></a>Untethered AR<a class="hash-link" href="#untethered-ar" title="Direct link to heading">#</a></h4><p>AR devices such as the microsoft Hololens is also supported by WebXR in the new Chromium Edge browser, enabling AR based apps to be build and deployed using only the web browser and Zea Engine.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_31ik" id="mobile"></a>Mobile<a class="hash-link" href="#mobile" title="Direct link to heading">#</a></h2><p>Support for mobile devices is improving as the browsers on those devices improve. Currently, Zea Engine supports mobile devices, but some rendering features may not work on all devices. Any browser that supports WebGL2 will be able to support Zea Engine. Check <a href="https://caniuse.com/?search=webgl2" target="_blank" rel="noopener noreferrer">here</a> for an updated view of which browsers/browser versions support WebGL2.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="ios"></a>iOS<a class="hash-link" href="#ios" title="Direct link to heading">#</a></h3><p>As of September 2021, iOS Safari browsers now supports WebGL2. </p><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="android"></a>Android<a class="hash-link" href="#android" title="Direct link to heading">#</a></h3><p>Android devices provide great support for WebGL through the installed chrome browser. However, not all hardware provides the same level of functionality, and so each device must be tested individually.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="microsoft-surface"></a>Microsoft Surface<a class="hash-link" href="#microsoft-surface" title="Direct link to heading">#</a></h3><p>The latest Microsoft surface hardware runs a full version of Windows 10 and so provide excellent support for Zea Engine and application built with it.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_31ik" id="class-hierarchy"></a>Class Hierarchy<a class="hash-link" href="#class-hierarchy" title="Direct link to heading">#</a></h2><p><img alt="renderer-class-hierarchy" src="/zea-engine/assets/images/renderer-class-hierarchy-730193841f8f7e2a8daa42537d953099.svg"></p><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_31ik" id="summary"></a>Summary<a class="hash-link" href="#summary" title="Direct link to heading">#</a></h2><p>In this section we explored the main architectural concepts of the engine, highlighting its design for performance, versatility, and customization.</p></div></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/zea-engine/Manual/Concepts/zea-engine-architecture"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">« Concepts Overview</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/zea-engine/Manual/Concepts/transformations"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">Transformations »</div></a></div></nav></div></div><div class="col col--3"><div class="tableOfContents_35-E thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#performance" class="table-of-contents__link">Performance</a></li><li><a href="#versatility" class="table-of-contents__link">Versatility</a></li><li><a href="#extensibility" class="table-of-contents__link">Extensibility</a></li><li><a href="#dom-analogy" class="table-of-contents__link">DOM Analogy</a><ul><li><a href="#events" class="table-of-contents__link">Events</a></li><li><a href="#web-components" class="table-of-contents__link">Web Components</a></li></ul></li><li><a href="#scene-tree" class="table-of-contents__link">Scene Tree</a><ul><li><a href="#parameters" class="table-of-contents__link">Parameters</a></li><li><a href="#paths" class="table-of-contents__link">Paths</a></li><li><a href="#operators" class="table-of-contents__link">Operators</a></li><li><a href="#lazy-evaluation" class="table-of-contents__link">Lazy Evaluation</a></li><li><a href="#renderer" class="table-of-contents__link">Renderer</a></li><li><a href="#renderer-as-an-observer-of-the-scene-tree" class="table-of-contents__link">Renderer as an observer of the Scene Tree</a></li><li><a href="#passes" class="table-of-contents__link">Passes</a></li><li><a href="#adaptors" class="table-of-contents__link">Adaptors</a></li><li><a href="#evented-rendering" class="table-of-contents__link">Evented Rendering</a></li><li><a href="#continuous-rendering" class="table-of-contents__link">Continuous Rendering</a></li><li><a href="#arvr" class="table-of-contents__link">AR/VR</a></li></ul></li><li><a href="#mobile" class="table-of-contents__link">Mobile</a><ul><li><a href="#ios" class="table-of-contents__link">iOS</a></li><li><a href="#android" class="table-of-contents__link">Android</a></li><li><a href="#microsoft-surface" class="table-of-contents__link">Microsoft Surface</a></li></ul></li><li><a href="#class-hierarchy" class="table-of-contents__link">Class Hierarchy</a></li><li><a href="#summary" class="table-of-contents__link">Summary</a></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">Zea</div><ul class="footer__items"><li class="footer__item"><a href="https://www.zea.live/" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>Website<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li><li class="footer__item"><a href="https://blog.zea.live/en/blog" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>Blog<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li></ul></div><div class="col footer__col"><div class="footer__title">Community</div><ul class="footer__items"><li class="footer__item"><a href="https://community.zea.live/" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>Zea Community<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li></ul></div><div class="col footer__col"><div class="footer__title">More</div><ul class="footer__items"><li class="footer__item"><a href="https://github.com/ZeaInc/zea-engine" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2021 Zea Inc.</div></div></div></footer></div>
<script src="/zea-engine/assets/js/runtime~main.14def733.js"></script>
<script src="/zea-engine/assets/js/main.83d89e4b.js"></script>
</body>
</html>